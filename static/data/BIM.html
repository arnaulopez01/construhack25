<!DOCTYPE html>

<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Visor BIM Simulado - Torre Residencial Barri de Llevant</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <style>
        body { margin: 0; overflow: hidden; font-family: 'Inter', sans-serif; background-color: #f0f4f8; }
        #bim-container {
            width: 100vw;
            height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        #info-panel {
            position: absolute;
            top: 10px;
            left: 10px;
            padding: 15px;
            background: rgba(255, 255, 255, 0.9);
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
            max-width: 350px;
            z-index: 10;
        }
        #info-panel h3 {
            margin-top: 0;
            color: #1f2937;
            border-bottom: 2px solid #ef4444; 
            padding-bottom: 5px;
            font-size: 1.1rem;
        }
        #info-panel p {
            margin: 5px 0;
            font-size: 0.9rem;
            color: #4b5563;
        }
        .status-badge {
            display: inline-block;
            padding: 2px 8px;
            border-radius: 4px;
            font-weight: bold;
            font-size: 0.75rem;
            margin-left: 5px;
        }
        .status-future { background-color: #d1fae5; color: #065f46; } 

        /* POP-UP de Información (Pop-up BIM) */
        #popup-info {
            position: absolute;
            background: #2c3e50; /* Fondo oscuro para destacar info BIM */
            color: #ecf0f1;
            padding: 10px 15px;
            border-radius: 6px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
            pointer-events: none; /* Ignora el ratón para no interferir con el raycaster */
            opacity: 0;
            transition: opacity 0.2s;
            z-index: 20;
        }
        #popup-info h4 {
            margin: 0 0 5px 0;
            font-size: 1rem;
            border-bottom: 1px solid #4b6782;
            padding-bottom: 3px;
        }
        #popup-info p {
            margin: 3px 0;
            font-size: 0.85rem;
            line-height: 1.3;
        }
    </style>
</head>
<body>

<div id="bim-container"></div>

<div id="info-panel">
    <h3>Modelo BIM Cargado (Georreferenciado)</h3>
    <p><strong>Obra:</strong> Torre Residencial Barri de Llevant</p>
    <p><strong>Altura Total:</strong> 30 metros (10 Plantas)</p>
    <p><strong>Ubicación (Lat/Lon):</strong> 41.322620, 2.028238</p>
    <p><strong>ID de Activo BIM:</strong> VLDC_OE_2026_0010_Mixto.i3s</p>
    <p><strong>Estado:</strong> <span class="status-badge status-future">A Futuro</span></p>
    <p style="margin-top: 15px; font-weight: bold; color: #007bff;">
        ⚠️ Haz clic en cualquier elemento (viga, pilar, fachada) para ver sus atributos BIM.
    </p>
    
    <p style="margin-top: 10px; font-style: italic; color: #9ca3af;">Simulación de edificio residencial único, tocando el suelo (Z=0) y con techo plano. Estructura interna visible.</p>
</div>

<!-- Pop-up donde se mostrarán los atributos BIM -->
<div id="popup-info"></div>

<script>
    // --- CONSTANTES DEL MODELO ---
    const totalHeight = 30; // Altura total actualizada a 30 metros
    const towerHeight = 30; // Altura de la torre actualizada
    const numFloors = 10; // Número de plantas actualizado para mantener 3m/planta (30/10=3)
    const floorHeight = towerHeight / numFloors;
    const GREY_COLOR = 0x7f8c8d; // Gris fachada
    const CONCRETE_PILLAR_COLOR = 0x4B5563; // Gris oscuro hormigón para pilares
    const STEEL_BEAM_COLOR = 0x2c3e50; // Azul oscuro/Gris grafito para simular acero
    
    // Configuración de la escena Three.js
    let scene, camera, renderer, controls;
    const container = document.getElementById('bim-container');
    const popupInfo = document.getElementById('popup-info');

    // Raycasting para interacción
    const raycaster = new THREE.Raycaster();
    const mouse = new THREE.Vector2();

    let INTERSECTED = null; // Objeto actualmente seleccionado/intersecado

    function init() {
        // 1. Escena
        scene = new THREE.Scene();
        scene.background = new THREE.Color(0xf0f4f8);

        // 2. Cámara
        camera = new THREE.PerspectiveCamera(75, container.clientWidth / container.clientHeight, 0.1, 1000);
        camera.position.set(25, totalHeight * 0.5, 30); 

        // 3. Renderer
        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(container.clientWidth, container.clientHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.shadowMap.enabled = true; 
        container.appendChild(renderer.domElement);

        // 4. Controles (Permite girar y hacer zoom)
        controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.minDistance = 10;
        controls.maxDistance = 100;
        controls.target.set(0, totalHeight / 2, 0); 

        // 5. Luces
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.7);
        scene.add(ambientLight);

        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.9);
        directionalLight.position.set(30, 40, 30);
        directionalLight.castShadow = true; 
        scene.add(directionalLight);

        // 6. Simulación del Modelo BIM (Edificio y Entorno)
        createBIMBuildingSimulation();
        
        // 7. Event Listeners para interacción
        window.addEventListener('resize', onWindowResize, false);
        window.addEventListener('click', onMouseClick, false);

        // Iniciar el loop de animación
        animate();
    }
    
    /**
     * Función que maneja el click del ratón para detectar e interactuar con objetos.
     */
    function onMouseClick(event) {
        // Normalizar coordenadas del ratón (-1 a +1)
        mouse.x = (event.clientX / container.clientWidth) * 2 - 1;
        mouse.y = - (event.clientY / container.clientHeight) * 2 + 1;

        // Actualizar raycaster con la cámara y la posición del ratón
        raycaster.setFromCamera(mouse, camera);

        // Calcular objetos que intersecan el rayo
        // Excluimos el suelo del rayo para que no interfiera
        const intersects = raycaster.intersectObjects(scene.children.filter(obj => obj.name !== 'ground'), true);

        if (intersects.length > 0) {
            // El primer objeto intersecado es el que nos interesa
            const hitObject = intersects[0].object;
            
            // Si el objeto tiene datos BIM adjuntos, los mostramos
            if (hitObject.userData.bimData) {
                showPopup(hitObject.userData.bimData, event.clientX, event.clientY);
            } else {
                hidePopup();
            }
        } else {
            // Si no se toca ningún objeto, se oculta el pop-up
            hidePopup();
        }
    }

    /**
     * Muestra el pop-up con la información BIM en la posición del click.
     */
    function showPopup(data, x, y) {
        let htmlContent = `<h4>${data.name}</h4>`;
        for (const [key, value] of Object.entries(data.attributes)) {
            htmlContent += `<p><strong>${key.charAt(0).toUpperCase() + key.slice(1)}:</strong> ${value}</p>`;
        }
        
        popupInfo.innerHTML = htmlContent;
        
        // Posicionamiento del pop-up (con un pequeño offset)
        popupInfo.style.left = `${x + 10}px`;
        popupInfo.style.top = `${y - 10}px`;
        popupInfo.style.opacity = 1;
    }
    
    /**
     * Oculta el pop-up.
     */
    function hidePopup() {
        popupInfo.style.opacity = 0;
    }


    function createStreetFurniture() {
        // ... (Mobiliario urbano: Farolas, Árboles. No necesitan BIM data para esta demo)
        const trunkMaterial = new THREE.MeshLambertMaterial({ color: 0x8B4513 }); 
        const leafMaterial = new THREE.MeshLambertMaterial({ color: 0x228B22 }); 
        const poleMaterial = new THREE.MeshLambertMaterial({ color: 0x34495e }); 
        const lightMaterial = new THREE.MeshBasicMaterial({ color: 0xFFFF99, transparent: true, opacity: 0.8 }); 

        function createTree(x, z) {
            const trunkHeight = 4;
            const trunkRadius = 0.4;
            const trunkGeometry = new THREE.CylinderGeometry(trunkRadius, trunkRadius, trunkHeight, 8);
            const trunk = new THREE.Mesh(trunkGeometry, trunkMaterial);
            trunk.position.set(x, trunkHeight / 2, z);

            const coneHeight = 6;
            const coneRadius = 3;
            const coneGeometry = new THREE.ConeGeometry(coneRadius, coneHeight, 16);
            const leaves = new THREE.Mesh(coneGeometry, leafMaterial);
            leaves.position.set(x, trunkHeight + coneHeight / 2, z);
            
            scene.add(trunk);
            scene.add(leaves);
        }

        function createLampPost(x, z) {
            const poleHeight = 10;
            const poleRadius = 0.15;
            
            const poleGeometry = new THREE.CylinderGeometry(poleRadius, poleRadius, poleHeight, 8);
            const pole = new THREE.Mesh(poleGeometry, poleMaterial);
            pole.position.set(x, poleHeight / 2, z);

            const fixtureGeometry = new THREE.BoxGeometry(0.8, 0.4, 0.8);
            const fixture = new THREE.Mesh(fixtureGeometry, lightMaterial);
            fixture.position.set(x, poleHeight + 0.2, z); 

            const pointLight = new THREE.PointLight(0xFFFF99, 1.5, 30); 
            pointLight.position.set(x, poleHeight, z);

            scene.add(pole);
            scene.add(fixture);
            scene.add(pointLight);
        }

        createLampPost(-12, 5); 
        createLampPost(12, -12); 
        
        createTree(-15, 8); 
        createTree(-18, -5);
        createTree(12, 12); 
        createTree(15, -10);
    }

    /**
     * Crea la estructura interna de hormigón (pilares) y acero (vigas) con atributos BIM.
     */
    function createConcreteStructure() {
        const pillarMaterial = new THREE.MeshLambertMaterial({ color: CONCRETE_PILLAR_COLOR });
        // Material para vigas (simulando Acero)
        const beamMaterial = new THREE.MeshLambertMaterial({ color: STEEL_BEAM_COLOR }); 
        
        const pillarXPositions = [-3, 3];
        const pillarZPositions = [-5, 0, 5];
        
        // Tamaños de elementos
        const pillarRadius = 0.3;
        const beamHeight = 0.4;
        const beamWidth = 0.4; 

        for (let i = 0; i < numFloors; i++) {
            const floorY = (i * floorHeight); 
            
            // 1. Crear Pilares (Columnas) - Hormigón
            const pillarGeometry = new THREE.CylinderGeometry(pillarRadius, pillarRadius, floorHeight, 8);
            
            pillarXPositions.forEach(px => {
                pillarZPositions.forEach(pz => {
                    const pillar = new THREE.Mesh(pillarGeometry, pillarMaterial);
                    pillar.position.set(px, floorY + (floorHeight / 2), pz);
                    
                    // --- Atributos BIM del Pilar ---
                    pillar.userData.bimData = {
                        name: `Pilar ${i+1}`,
                        attributes: {
                            función: 'Estructural - Carga Vertical',
                            material: 'Hormigón Armado C25/30',
                            sección: `Cilíndrica, D=${pillarRadius * 2}m`,
                            planta: i + 1,
                            código: `P-${i+1}-${px > 0 ? 'E' : 'W'}-${pz > 0 ? 'N' : (pz < 0 ? 'S' : 'C')}`
                        }
                    };
                    scene.add(pillar);
                });
            });
            
            // 2. Crear Vigas (Beams) - Acero
            
            // Vigas en dirección Z
            pillarXPositions.forEach(px => {
                for(let j = 0; j < pillarZPositions.length - 1; j++) {
                    const z1 = pillarZPositions[j];
                    const z2 = pillarZPositions[j+1];
                    const beamLength = Math.abs(z2 - z1);
                    const beamGeometry = new THREE.BoxGeometry(beamWidth, beamHeight, beamLength);
                    
                    const beam = new THREE.Mesh(beamGeometry, beamMaterial);
                    beam.position.set(px, floorY + (beamHeight / 2), (z1 + z2) / 2);
                    
                    // --- Atributos BIM de la Viga de Acero ---
                    beam.userData.bimData = {
                        name: `Viga ${i+1} Longitudinal`,
                        attributes: {
                            función: 'Estructural - Forjado',
                            material: 'Acero Estructural S275',
                            sección: `Rectangular ${beamWidth}x${beamHeight}m (Sim. HEB-400)`,
                            planta: i + 1,
                            código: `V-Z-${i+1}-${px > 0 ? 'E' : 'W'}`
                        }
                    };
                    scene.add(beam);
                }
            });

            // Vigas en dirección X
            pillarZPositions.forEach(pz => {
                 for(let k = 0; k < pillarXPositions.length - 1; k++) {
                    const x1 = pillarXPositions[k];
                    const x2 = pillarXPositions[k+1];
                    const beamLength = Math.abs(x2 - x1);
                    const beamGeometry = new THREE.BoxGeometry(beamLength, beamHeight, beamWidth);
                    
                    const beam = new THREE.Mesh(beamGeometry, beamMaterial);
                    beam.position.set((x1 + x2) / 2, floorY + (beamHeight / 2), pz);
                    
                    // --- Atributos BIM de la Viga de Acero ---
                    beam.userData.bimData = {
                        name: `Viga ${i+1} Transversal`,
                        attributes: {
                            función: 'Estructural - Forjado',
                            material: 'Acero Estructural S275',
                            sección: `Rectangular ${beamLength}x${beamHeight}m (Sim. IPE-360)`,
                            planta: i + 1,
                            código: `V-X-${i+1}-${pz > 0 ? 'N' : (pz < 0 ? 'S' : 'C')}`
                        }
                    };
                    scene.add(beam);
                }
            });
        }
    }

    function createBIMBuildingSimulation() {
        // Suelo (Cota 0) - Mantenido para el contexto visual
        const groundGeometry = new THREE.PlaneGeometry(50, 50);
        const groundMaterial = new THREE.MeshLambertMaterial({ color: 0xcccccc });
        const ground = new THREE.Mesh(groundGeometry, groundMaterial);
        ground.rotation.x = -Math.PI / 2;
        ground.position.y = 0;
        ground.receiveShadow = true; 
        ground.name = 'ground'; // Nombre para excluirlo del raycast
        scene.add(ground);

        // 1. Torre Residencial - Fachada
        const towerWidth = 10; 
        const towerDepth = 15; 
        const towerGeometry = new THREE.BoxGeometry(towerWidth, towerHeight, towerDepth);
        
        // Material gris semitransparente para la FACHADA
        const towerMaterial = new THREE.MeshLambertMaterial({ 
            color: GREY_COLOR,
            transparent: true,
            opacity: 0.4 
        }); 
        const tower = new THREE.Mesh(towerGeometry, towerMaterial);
        
        tower.position.y = towerHeight / 2; 
        tower.position.x = 0; 
        tower.position.z = 0; 
        
        // --- Atributos BIM de la Fachada (El volumen completo) ---
        tower.userData.bimData = {
            name: 'Fachada/Cerramiento',
            attributes: {
                tipo: 'Muro cortina ligero',
                material: 'Vidrio/Cerámico Opaco',
                u_valor: '0.9 W/(m²·K)', // Aislamiento térmico
                superficie: `${(towerWidth * towerHeight * 2 + towerDepth * towerHeight * 2).toFixed(0)} m²`
            }
        };

        scene.add(tower);

        // 2. Estructura de Hormigón y Acero
        createConcreteStructure();
        
        // 3. Techo plano (simulación)
        const roofGeometry = new THREE.PlaneGeometry(towerWidth, towerDepth);
        const roofMaterial = new THREE.MeshLambertMaterial({ color: GREY_COLOR });
        const roof = new THREE.Mesh(roofGeometry, roofMaterial);
        roof.rotation.x = -Math.PI / 2; 
        roof.position.y = towerHeight; 
        roof.position.x = tower.position.x;
        roof.position.z = tower.position.z;
        
        // --- Atributos BIM del Techo ---
        roof.userData.bimData = {
            name: 'Cubierta Plana',
            attributes: {
                tipo: 'Cubierta invertida no transitable',
                material: 'Membrana asfáltica y grava',
                pendiente: '2%', 
                aislamiento: 'XPS 15cm'
            }
        };
        scene.add(roof);

        // 4. Ventanas - Simulación de huecos
        const windowMaterial = new THREE.MeshLambertMaterial({ color: 0x374151, emissive: 0x374151 }); 
        for (let i = 0; i < numFloors; i++) {
            const y = (i * floorHeight) + (floorHeight / 2); // Centro de la planta
            
            // Simulación de varias ventanas/huecos
            for (let j = -1; j <= 1; j++) { 
                const windowGeometry = new THREE.BoxGeometry(1.5, floorHeight * 0.6, 0.1);
                
                // Ventanas Frontales
                const windowMeshFront = new THREE.Mesh(windowGeometry, windowMaterial);
                windowMeshFront.position.set(tower.position.x + j * 3, y, tower.position.z + towerDepth / 2 - 0.1);
                windowMeshFront.userData.bimData = {
                    name: 'Ventana/Hueco',
                    attributes: {
                        tipo: 'Ventana Proyectante',
                        material: 'Doble acristalamiento (4+12+4)',
                        perfil: 'Aluminio RPT',
                        planta: i + 1,
                    }
                };
                scene.add(windowMeshFront);
                
                // Ventanas Traseras (solo para la demostración de pop-up)
                const windowMeshBack = new THREE.Mesh(windowGeometry, windowMaterial);
                windowMeshBack.position.set(tower.position.x + j * 3, y, tower.position.z - (towerDepth / 2) + 0.1);
                windowMeshBack.userData.bimData = windowMeshFront.userData.bimData;
                scene.add(windowMeshBack);
            }
        }
        
        // 5. Entorno Urbano
        createStreetFurniture();
    }

    function onWindowResize() {
        camera.aspect = container.clientWidth / container.clientHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(container.clientWidth, container.clientHeight);
    }

    function animate() {
        requestAnimationFrame(animate);
        controls.update();
        renderer.render(scene, camera);
    }
    
    window.onload = init;
</script>
</body>
</html>